### The Automatic Exploitation Procedure
### Setting Exploitable Requirements
Exploitable browser requirements are defined under "BrowserRequirements" in the module's metadata. Here's an example of defining a vulnerable target running some ActiveX control:
```ruby
'BrowserRequirements' =>
{
	source: /script/i,
        activex: [
          {
            clsid: '{D27CDB6E-AE6D-11cf-96B8-444553540000}',
            method: 'LoadMovie'
          }
        ],
	os_name: /win/i
}
```

You can also define target-specific requirements. This is also how the mixin is able to automatically select a target, and you can get it with the "get_target" method. Here's an example of how to define target-specific requirements for IE8 on Win XP and IE 9 on Win 7:
```ruby
'BrowserRequirements' =>
  {
    :source   => /script|headers/i,
    'ua_name' => HttpClients::IE,
  },
'Targets'             =>
  [
    [ 'Automatic', {} ],
    [
      'Windows XP with IE 8',
      {
        :os_name    => 'Windows XP',
        'ua_ver'    => '8.0',
        'Rop'       => true,
        'Offset'    => 0x100
      }
    ],
    [
      'Windows 7 with IE 9',
      {
        'os_name'   => 'Windows 7',
        'ua_ver'    => '9.0',
        'Rop'       => true,
        'Offset'    => 0x200
      }
    ]
  ]
```

### Set up a listener
After the detection stage and the requirement check, the mixin will trigger the "on_request_exploit" callback method, that's where you handle the HTTP request, craft the HTML, and send back the exploit response. Here's an example of how to set up "on_request_exploit":
```ruby
#
# Listens for the HTTP request
# cli is the socket
# request is the Rex::Proto::Http::Request object
# target_info is a hash that contains all the browser info (aka the profile)
#
def on_request_exploit(cli, request, target_info)
	print_status("Here's what I know about the target: #{target_info.inspect}")
end
```

### Crafting HTML with BrowserExploitServer
There are two coding styles the BrowserExploitServer mixin supports: The good old HTML, or [ERB](http://ruby-doc.org/stdlib-2.1.3/libdoc/erb/rdoc/ERB.html) template. The first is pretty self-explanatory:
```ruby
def on_request_exploit(cli, request, target_info)
	html = %Q|
	<html>
	Hello, world!
	</html>
	|
	send_exploit_html(cli, html)
end
```

[ERB](http://ruby-doc.org/stdlib-2.1.3/libdoc/erb/rdoc/ERB.html) is a new way to write Metasploit browser exploits. If you've written one or two web applications, this is no stranger to you. When you're using the BrowserExploitServer mixin to write an exploit, what really happens is you're writing a rails template. Here's an example of using of this feature:
```ruby
def on_request_exploit(cli, request, target_info)
	html = %Q|
	<html>
	Do you feel lucky, punk?<br>
	<% if [true, false].sample %>
	Lucky!<br>
	<% else %>
	Bad luck, bro!<Br>
	<% end %>
	</html>
	|
	send_exploit_html(cli, html)
end
```

If you want to access local variables or arguments, make sure to pass the binding object to send_exploit_html:
```ruby
def exploit_template1(target_info, txt)
	txt2 = "I can use local vars!"

	template = %Q|
	<% msg = "This page is generated by an exploit" %>
	<%=msg%><br>
	<%=txt%><br>
	<%=txt2%><br>
	<p></p>
	Data gathered from source: #{target_info[:source]}<br>
	OS name: #{target_info[:os_name]}<br>
	UA name: #{target_info[:ua_name]}<br>
	UA version: #{target_info[:ua_ver]}<br>
	Java version: #{target_info[:java]}<br>
	Office version: #{target_info[:office]}
	|

	return template, binding()
end

def on_request_exploit(cli, request, target_info)
	send_exploit_html(cli, exploit_template(target_info, txt))
end
```

To get thing started, here's a code example you can use start developing your browser exploit:
```ruby
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::BrowserExploitServer

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'BrowserExploitServer Example',
        'Description' => %q{
          This is an example of building a browser exploit using the BrowserExploitServer mixin
        },
        'License' => MSF_LICENSE,
        'Author' => [ 'sinn3r' ],
        'References' => [
          [ 'URL', 'http://metasploit.com' ]
        ],
        'Platform' => 'win',
        'BrowserRequirements' => {
          source: /script|headers/i
        },
        'Targets' => [
          [ 'Automatic', {} ],
          [
            'Windows XP with IE 8',
            {
              'os_name' => 'Windows XP',
              'ua_name' => 'MSIE',
              'ua_ver' => '8.0'
            }
          ],
          [
            'Windows 7 with IE 9',
            {
              'os_name' => 'Windows 7',
              'ua_name' => 'MSIE',
              'ua_ver' => '9.0'
            }
          ]
        ],
        'Payload' => { 'BadChars' => "\x00" },
        'DisclosureDate' => '2013-04-01',
        'DefaultTarget' => 0
      )
    )
  end

  def exploit_template(target_info)
    template = %(
    Data source: <%=target_info[:source]%><br>
    OS name: <%=target_info[:os_name]%><br>
    UA name: <%=target_info[:ua_name]%><br>
    UA version: <%=target_info[:ua_ver]%><br>
    Java version: <%=target_info[:java]%><br>
    Office version: <%=target_info[:office]%>
    )

    return template, binding
  end

  def on_request_exploit(cli, _request, target_info)
    send_exploit_html(cli, exploit_template(target_info))
  end

end
```

### JavaScript Obfuscation
BrowserExploitServer relies on the [JSObfu mixin](https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/jsobfu.rb) to support JavaScript obfuscation. When you're writing JavaScript, you should always write it like this:
```ruby
js = js_obfuscate(your_code)
```

The
```#js_obfuscate```

will return a
```Rex::Exploitation::JSObfu```

object. To get the obfuscated JavaScript, call the
```#to_s```

method:
```ruby
js.to_s
```

If you need to access an obfuscated symbol name, you can use then
```#sym```

method:
```ruby
# Get the obfuscated version of function name test()
var_name = js.sym('test')
```

Note that by default, even though your module is calling the
```#js_obfuscate```

If your BES-based exploit does not want obfuscation at all, always make sure you call the
```#deregister_options```

and remove the JsObfuscate option. Like this:
```ruby
deregister_options('JsObfuscate')
```

