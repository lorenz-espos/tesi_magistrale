# How to use the Msf::Exploit::Remote::Tcp mixin
## Using the mixin
To use the mixin, simply add the following statement within your module's
```class Metasploit3```

(or
```class Metasploit4```

) scope:
```ruby
include Msf::Exploit::Remote::Tcp
```

## Make a connection
To make a connection, simply do the following:
```ruby
connect
```

When you do this, what happens is that the
```connect```

method will call
```Rex::Socket::Tcp.create```

to create the socket, and register it to framework. It automatically checks with the RHOST/RPORT datastore options (so it knows where to connect to), but you can also manually change this:
```ruby
# This connects to metasploit.com
connect(true, {'RHOST'=>'208.118.237.137', 'RPORT'=>80})
```

The
```connect```

But you see, there's a little more to it. The
```connect```

So to sum it up, ideally when you use the
```connect```

method, you should rescue these:
```ruby
rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused
```

## Sending data
There are several ways to send data with the Tcp mixin. To make things easier and safer, we recommend just use the
```put```

method:
```ruby
sock.put "Hello, World!"
```

The reason the
```put```

method is safer is because it does not allow the routine to hang forever. By default, it doesn't wait, but if you want to make this more flexible, you can do this:
```ruby
begin
	sock.put("data", {'Timeout'=>5})
rescue ::Timeout::Error
	# You can decide what to do if the writing times out
end
```

## Receiving data
Now, let's talk about how to receive data. Mainly there are three methods you can use: `get_once`, `get`, and `timed_read`. The difference is that `get_once` will only try to poll the stream to see if there's any read data available **one time**, but the
```get```

method will keep reading until there is no more. As for
```timed_read```

, it's basically the
```read```

The following demonstrates how `get_once` is used:
```ruby
begin
	buf = sock.get_once
rescue ::EOFError
end
```

Note that
```get_once```

## Disconnecting
To disconnect the connection, simply do:
```ruby
disconnect
```

It is VERY important you disconnect in an
```ensure```

## Full example
The following example should demonstrate how you would typically want to use the Tcp mixin:
```ruby
# Sends data to the remote machine
#
# @param data [String] The data to send
# @return [String] The received data
def send_recv_once(data)
  buf = ''
  begin
    connect
    sock.put(data)
    buf = sock.get_once || ''
  rescue Rex::AddressInUse, ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError => e
    elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
  ensure
    disconnect
  end

  buf
end
```

