### Building a Repository
Let's say that the repository is something like the following:
```
space@vm:~/test-repo$ ls -al
total 20
drwxrwxr-x  4 space space 4096 Sep 16 14:06 .
drwxr-x--- 23 space space 4096 Sep 16 14:05 ..
drwxrwxr-x  2 space space 4096 Sep 16 14:06 dir
-rw-rw-r--  1 space space   10 Sep 16 14:06 file.txt
drwxrwxr-x  7 space space 4096 Sep 16 14:06 .git
space@vm:~/test-repo$ ls -al dir
total 12
drwxrwxr-x 2 space space 4096 Sep 16 14:06 .
drwxrwxr-x 4 space space 4096 Sep 16 14:06 ..
-rw-rw-r-- 1 space space    5 Sep 16 14:06 test_file.txt
```

needs to be created to represent the contents of `test_file.txt`:
```
space@vm:~/test-repo$ cat dir/test_file.txt 
test
```

To build a blob object, the `build_blob_object()` class method should be used:
```
>> contents = "test\n"
=> "test\n"
>> blob = Msf::Exploit::Git::GitObject.build_blob_object(contents)
=> 
#<Msf::Exploit::Git::GitObject:0x00007fe163c75cd0                                            
```

where each hash looks like the following:
```
>> tree_entry =
{
	mode: '100644',
	file_name: 'test_file.txt',
	sha1: blob.sha1
}
```

And using that, the tree object can now be created:
```
>> tree_object = Msf::Exploit::Git::GitObject.build_tree_object(tree_entry)
=> 
#<Msf::Exploit::Git::GitObject:0x00007fe161b0cd78
```

Again, a blob object needs to be created to represent the contents of the remaining file:
```
space@vm:~/test-repo$ cat file.txt
some text
```


```
>> contents = "some text\n"
=> "some text\n"
>> file_blob = Msf::Exploit::Git::GitObject.build_blob_object(contents)
=> 
#<Msf::Exploit::Git::GitObject:0x00007fe163bf54b8                                              
...                                                                                            
```

which includes `file.txt` and the `dir` folder:
```
?> entries = [
?>   {
?>     mode: '100644',
?>     file_name: 'file.txt',
?>     sha1: file_blob.sha1
?>   },
?>   {
?>     mode: '040000',
?>     file_name: 'dir',
?>     sha1: tree_object.sha1
?>   }
>> ]
=> [{:mode=>"100644", :file_name=>"file.txt", :sha1=>"b649a9bf89116c581f8329b8ec3c79a86a70...
>> top_level_obj = Msf::Exploit::Git::GitObject.build_tree_object(entries)
```

random data for them.
```
>> commit_object = Msf::Exploit::Git::GitObject.build_commit_object(tree_sha1: top_level_obj.sh
a1)
=> 
#<Msf::Exploit::Git::GitObject:0x00007fe1533ac848                                              
...                                                                                            
>> commit_object
=> 
#<Msf::Exploit::Git::GitObject:0x00007fe1533ac848                                              
 @compressed=                                                                                  
  "x\x9C\x95\xCEA\x0E\xC2 \x10\x05P\xD7\x9Cb<@\r\x1DZ\xCA\xC2\x18\xE3\xCE\xA8g0XF!\xB6\xD0\x00]x{I\xED\x05\\\xCD\xE4'\xF3\xFE\xF4a\x1C]\x06\x14j\x93#\x11pe\b\el5u]cL#\xD1\x18\xC9\x05\x97\x92\x04*\xF3h\xA5P}\xC7\x89\xE99\xDB\x10\xE1\xEA\x92\xF6&j\xB8\xCC\x93\xD5\x03\xEC\xDF\xCB\xBC\x0Fk~\xB43\ri\xE7)\x1F\xA0\xAEU[\x10l\x05T\x85\xE4\xAC_\xCA3\xFD\xC7\xA8\x0E%\nQ\xE3\xAA\xB0\xB3w\xD9\x95\xA3\x1F\a9@\x98\xC8\xC3\xAB\xEC\x91\xA6\x90\\\x0E\xF1\x03\xCF\xF2\xED\xC9\xF9T\xDD\x82\x8D[\xF6\x05s\xF7P\x89",                                                                       
 @content=                                                                                     
  "tree 08de2425ae774dd462dd603066e328db5638c70e\nauthor Lisandra Kuphal <kuphal_lisandra@huels.net> 1185328253 -0300\ncommitter Lisandra Kuphal <kuphal_lisandra@huels.net> 872623312 -0300\n\nInitial commit to open git repository for Bins-Mohr!\n",
 @path="01/8856fe17403b0991e5d1d3eb7f62dca4d8e951",
 @sha1="018856fe17403b0991e5d1d3eb7f62dca4d8e951",
 @type="commit">
```

### Hosting the Repository
can happen there:
```ruby
  # Creates a random uri for the Git repo, ensuring that there are no spaces
  def create_git_uri
    "/#{Faker::App.name.downcase}.git".gsub(' ', '-')
  end

  # Uses GIT_URI datastore option or randomly generates a repo URI
  # Registers the URI with the http server and prints the entire path that client should pass to git clone
  def primer
    @git_repo_uri = datastore['GIT_URI'].empty? ? create_git_uri : datastore['GIT_URI']
    @git_addr = URI.parse(get_uri).merge(@git_repo_uri)
    print_status("Git repository to clone: #{@git_addr}")
    hardcoded_uripath(@git_repo_uri)
  end
```

in the repo. This can be represented as the following hash:
```ruby
refs =
{
	'HEAD' => 'refs/heads/master',
	'refs/heads/master' => commit_object.sha1
}
```

After the response is built, it can be sent back to the client.:
```ruby
response = get_ref_discovery_response(request, @refs)
cli.send_response(response)
```

the requested object hashes.
```ruby
response = get_upload_pack_response(request, @git_objs)
cli.send_response(response)
```

Putting it all together, the module should look something like the following:
```ruby
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Git
  include Msf::Exploit::Git::SmartHttp
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Git Clone Test',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [ ],
        'References' => [ ],
        'DisclosureDate' => '2022-09-22',
        'Platform' => [ 'unix' ],
        'Arch' => ARCH_CMD,
        'Targets' => [
          [ 'Automatic Target', {}]
        ],
        'DefaultTarget' => 0,
        'Notes' => {}
      )
    )

    register_options(
      [
        OptString.new('GIT_URI', [ false, 'The URI to use as the malicious Git instance (empty for random)', '' ])
      ]
    )

    deregister_options('RHOSTS', 'RPORT')
  end

  def exploit
    setup_repo_structure
    super
  end

  def setup_repo_structure
    # create blob object for contents of 'test_file.txt'
    contents = "test\n"
    blob = Msf::Exploit::Git::GitObject.build_blob_object(contents)

    # create tree object representing 'test_file.txt' in 'dir' folder
    tree_entry =
    {
      mode: '100644',
      file_name: 'test_file.txt',
      sha1: blob.sha1
    }
    tree_object = Msf::Exploit::Git::GitObject.build_tree_object(tree_entry)

    # create blob object for contents of 'file.txt'
    contents = "some text\n"
    file_blob = Msf::Exploit::Git::GitObject.build_blob_object(contents)

    # create tree object representing top-level directory of repo
    entries =
    [
      {
        mode: '100644',
        file_name: 'file.txt',
        sha1: file_blob.sha1
      },
      {
        mode: '040000',
        file_name: 'dir',
        sha1: tree_object.sha1
      }
    ]
    top_level_obj = Msf::Exploit::Git::GitObject.build_tree_object(entries)

    # create commit
    commit_object = Msf::Exploit::Git::GitObject.build_commit_object(tree_sha1: top_level_obj.sha1)

    # create list of objects in repository, as the
    # client will request them to build the repository
    @git_objs =
      [
        commit_object, top_level_obj, tree_object,
        file_blob, tree_object, blob
      ]

    @refs =
      {
        'HEAD' => 'refs/heads/master',
        'refs/heads/master' => commit_object.sha1
      }
  end

  def create_git_uri
    "/#{Faker::App.name.downcase}.git".gsub(' ', '-')
  end

  def primer
    @git_repo_uri = datastore['GIT_URI'].empty? ? create_git_uri : datastore['GIT_URI']
    @git_addr = URI.parse(get_uri).merge(@git_repo_uri)
    print_status("Git repository to clone: #{@git_addr}")
    hardcoded_uripath(@git_repo_uri)
  end

  def on_request_uri(cli, req)
    request = Msf::Exploit::Git::SmartHttp::Request.parse_raw_request(req)
    case request.type
    when 'ref-discovery'
      response = get_ref_discovery_response(request, @refs)
      fail_with(Failure::UnexpectedReply, 'Git client did not send a valid ref-discovery request') unless response
    when 'upload-pack'
      response = get_upload_pack_response(request, @git_objs)
      fail_with(Failure::UnexpectedReply, 'Git client did not send a valid upload-pack request') unless response
    else
      fail_with(Failure::UnexpectedReply, 'Git client did not send a valid request')
    end

    cli.send_response(response)
  end
end
```

### Running the module
The module will start the http server and print the repo to clone
```msf
msf6 > use exploit/multi/http/git_clone_test
[*] No payload configured, defaulting to cmd/unix/python/meterpreter/reverse_tcp
msf6 exploit(multi/http/git_clone_test) > set srvport 9999
srvport => 9999
msf6 exploit(multi/http/git_clone_test) > set lhost 192.168.140.1
lhost => 192.168.140.1
msf6 exploit(multi/http/git_clone_test) > set srvhost 192.168.140.1
srvhost => 192.168.140.1
msf6 exploit(multi/http/git_clone_test) > run
[*] Exploit running as background job 0.
[*] Exploit completed, but no session was created.

msf6 exploit(multi/http/git_clone_test) > [*] Started reverse TCP handler on 192.168.140.1:4444 
[*] Using URL: http://192.168.140.1:9999/MOYuJfC
[*] Server started.
[*] Git repository to clone: http://192.168.140.1:9999/y-find.git
```

Once the repository is cloned, you should expect to see the same contents as the `test-repo` at the beginning of this document:
```
space@ubuntu:~$ git clone http://192.168.140.1:9999/y-find.git
Cloning into 'y-find'...
remote: Enumerating objects: 6, done.
remote: Counting objects: 100% (6/6), done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (6/6), 401 bytes | 200.00 KiB/s, done.
space@ubuntu:~$ cd y-find
space@ubuntu:~/y-find$ ls -al
total 20
drwxrwxr-x  4 space space 4096 Sep 22 12:05 .
drwxr-x--- 22 space space 4096 Sep 22 12:05 ..
drwxrwxr-x  2 space space 4096 Sep 22 12:05 dir
-rw-rw-r--  1 space space   10 Sep 22 12:05 file.txt
drwxrwxr-x  8 space space 4096 Sep 22 12:05 .git
space@ubuntu:~/y-find$ cat dir/test_file.txt 
test
space@ubuntu:~/y-find$ cat file.txt
some text
```

